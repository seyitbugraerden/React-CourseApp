"use client";
import {
  ChevronRightIcon
} from "./chunk-OFHIZEKT.js";
import {
  CheckIcon,
  SearchIcon,
  TimesIcon
} from "./chunk-KVZAV7EW.js";
import {
  CSSTransition,
  ChevronDownIcon,
  OverlayService
} from "./chunk-KYU435C4.js";
import {
  IconBase,
  Ripple,
  SpinnerIcon
} from "./chunk-CZ7JIBXQ.js";
import {
  ComponentBase,
  DomHandler,
  IconUtils,
  ObjectUtils,
  Portal,
  PrimeReact,
  PrimeReactContext,
  Tooltip,
  UniqueComponentId,
  ZIndexUtils,
  classNames,
  localeOption,
  useHandleStyle,
  useMergeProps,
  useMountEffect,
  useOverlayListener,
  useUnmountEffect,
  useUpdateEffect
} from "./chunk-4K5URFWW.js";
import "./chunk-ZW7WJ6XU.js";
import {
  require_react
} from "./chunk-4D5CYJYK.js";
import {
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/primereact/treeselect/treeselect.esm.js
var React3 = __toESM(require_react());

// node_modules/primereact/tree/tree.esm.js
var React2 = __toESM(require_react());

// node_modules/primereact/icons/minus/index.esm.js
var React = __toESM(require_react());
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var MinusIcon = React.memo(React.forwardRef(function(inProps, ref) {
  var pti = IconBase.getPTI(inProps);
  return React.createElement("svg", _extends({
    ref,
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, pti), React.createElement("path", {
    d: "M13.2222 7.77778H0.777778C0.571498 7.77778 0.373667 7.69584 0.227806 7.54998C0.0819442 7.40412 0 7.20629 0 7.00001C0 6.79373 0.0819442 6.5959 0.227806 6.45003C0.373667 6.30417 0.571498 6.22223 0.777778 6.22223H13.2222C13.4285 6.22223 13.6263 6.30417 13.7722 6.45003C13.9181 6.5959 14 6.79373 14 7.00001C14 7.20629 13.9181 7.40412 13.7722 7.54998C13.6263 7.69584 13.4285 7.77778 13.2222 7.77778Z",
    fill: "currentColor"
  }));
}));
MinusIcon.displayName = "MinusIcon";

// node_modules/primereact/tree/tree.esm.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$2(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread();
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t)
          return;
        f = false;
      } else
        for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
          ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest();
}
var useUpdateEffect2 = function useUpdateEffect3(fn, deps) {
  var mounted = React2.useRef(false);
  return React2.useEffect(function() {
    if (!mounted.current) {
      mounted.current = true;
      return;
    }
    return fn && fn();
  }, deps);
};
var classes = {
  container: "p-tree-container",
  loadingIcon: "p-tree-loading-icon",
  loadingOverlay: "p-tree-loading-overlay p-component-overlay",
  searchIcon: "p-tree-filter-icon",
  filterContainer: "p-tree-filter-container",
  input: "p-tree-filter p-inputtext p-component",
  header: "p-tree-header",
  footer: "p-tree-footer",
  root: function root(_ref) {
    var props = _ref.props;
    return classNames("p-tree p-component", {
      "p-tree-selectable": props.selectionMode,
      "p-tree-loading": props.loading,
      "p-disabled": props.disabled
    });
  },
  label: "p-treenode-label",
  checkboxIcon: "p-checkbox-icon p-c",
  checkboxContainer: "p-checkbox p-component",
  checkbox: function checkbox(_ref2) {
    var props = _ref2.nodeProps, checked = _ref2.checked, partialChecked = _ref2.partialChecked;
    return classNames("p-checkbox-box", {
      "p-highlight": checked,
      "p-indeterminate": partialChecked,
      "p-disabled": props.disabled
    });
  },
  nodeIcon: "p-treenode-icon",
  togglerIcon: "p-tree-toggler-icon",
  toggler: "p-tree-toggler p-link",
  droppoint: "p-treenode-droppoint",
  content: function content(_ref3) {
    var props = _ref3.nodeProps, checked = _ref3.checked, selected = _ref3.selected, isCheckboxSelectionMode = _ref3.isCheckboxSelectionMode;
    return classNames("p-treenode-content", {
      "p-treenode-selectable": props.selectionMode && props.node.selectable !== false,
      "p-highlight": isCheckboxSelectionMode() ? checked : selected,
      "p-highlight-contextmenu": props.contextMenuSelectionKey && props.contextMenuSelectionKey === props.node.key,
      "p-disabled": props.disabled
    });
  },
  subgroup: "p-treenode-children",
  node: function node(_ref4) {
    var isLeaf = _ref4.isLeaf;
    return classNames("p-treenode", {
      "p-treenode-leaf": isLeaf
    });
  }
};
var styles = "\n@layer primereact {\n    .p-tree-container {\n        margin: 0;\n        padding: 0;\n        list-style-type: none;\n        overflow: auto;\n    }\n\n    .p-treenode-children {\n        margin: 0;\n        padding: 0;\n        list-style-type: none;\n    }\n\n    .p-treenode-selectable {\n        cursor: pointer;\n        user-select: none;\n    }\n\n    .p-tree-toggler {\n        cursor: pointer;\n        user-select: none;\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n        overflow: hidden;\n        position: relative;\n    }\n\n    .p-treenode-leaf > .p-treenode-content .p-tree-toggler {\n        visibility: hidden;\n    }\n\n    .p-treenode-content {\n        display: flex;\n        align-items: center;\n    }\n\n    .p-tree-filter {\n        width: 100%;\n    }\n\n    .p-tree-filter-container {\n        position: relative;\n        display: block;\n        width: 100%;\n    }\n\n    .p-tree-filter-icon {\n        position: absolute;\n        top: 50%;\n        margin-top: -.5rem;\n    }\n\n    .p-tree-loading {\n        position: relative;\n        min-height: 4rem;\n    }\n\n    .p-tree .p-tree-loading-overlay {\n        position: absolute;\n        z-index: 1;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n}\n";
var TreeBase = ComponentBase.extend({
  defaultProps: {
    __TYPE: "Tree",
    __parentMetadata: null,
    id: null,
    value: null,
    checkboxIcon: null,
    disabled: false,
    selectionMode: null,
    selectionKeys: null,
    onSelectionChange: null,
    contextMenuSelectionKey: null,
    onContextMenuSelectionChange: null,
    expandedKeys: null,
    ariaLabel: null,
    ariaLabelledBy: null,
    style: null,
    className: null,
    contentStyle: null,
    contentClassName: null,
    metaKeySelection: true,
    propagateSelectionUp: true,
    propagateSelectionDown: true,
    loading: false,
    loadingIcon: null,
    expandIcon: null,
    collapseIcon: null,
    dragdropScope: null,
    header: null,
    footer: null,
    showHeader: true,
    filter: false,
    filterIcon: null,
    filterValue: null,
    filterBy: "label",
    filterMode: "lenient",
    filterPlaceholder: null,
    filterLocale: void 0,
    filterTemplate: null,
    level: 0,
    nodeTemplate: null,
    togglerTemplate: null,
    onSelect: null,
    onUnselect: null,
    onExpand: null,
    onCollapse: null,
    onToggle: null,
    onDragDrop: null,
    onContextMenu: null,
    onFilterValueChange: null,
    onNodeClick: null,
    onNodeDoubleClick: null,
    children: void 0
  },
  css: {
    classes,
    styles
  }
});
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var UITreeNode = React2.memo(function(props) {
  var contentRef = React2.useRef(null);
  var elementRef = React2.useRef(null);
  var nodeTouched = React2.useRef(false);
  var mergeProps = useMergeProps();
  var isLeaf = props.isNodeLeaf(props.node);
  var label2 = props.node.label;
  var expanded = (props.expandedKeys ? props.expandedKeys[props.node.key] !== void 0 : false) || props.node.expanded;
  var ptm = props.ptm, cx = props.cx;
  var getPTOptions = function getPTOptions2(key) {
    return ptm(key, {
      hostName: props.hostName,
      context: {
        selected: !isCheckboxSelectionMode() ? isSelected() : false,
        expanded: expanded || false,
        checked: isCheckboxSelectionMode() ? isChecked() : false,
        isLeaf
      }
    });
  };
  var expand = function expand2(event) {
    var navigateFocusToChild = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var expandedKeys = props.expandedKeys ? _objectSpread$1({}, props.expandedKeys) : {};
    expandedKeys[props.node.key] = true;
    props.onToggle({
      originalEvent: event,
      value: expandedKeys,
      navigateFocusToChild
    });
    invokeToggleEvents(event, true);
  };
  var collapse = function collapse2(event) {
    var expandedKeys = _objectSpread$1({}, props.expandedKeys);
    delete expandedKeys[props.node.key];
    props.onToggle({
      originalEvent: event,
      value: expandedKeys
    });
    invokeToggleEvents(event, false);
  };
  var onTogglerClick = function onTogglerClick2(event) {
    if (props.disabled) {
      return;
    }
    expanded ? collapse(event) : expand(event, false);
    event.preventDefault();
    event.stopPropagation();
  };
  var invokeToggleEvents = function invokeToggleEvents2(event, isExpanded) {
    if (isExpanded) {
      if (props.onExpand) {
        props.onExpand({
          originalEvent: event,
          node: props.node
        });
      }
    } else {
      if (props.onCollapse) {
        props.onCollapse({
          originalEvent: event,
          node: props.node
        });
      }
    }
  };
  var findNextSiblingOfAncestor = function findNextSiblingOfAncestor2(nodeElement) {
    var parentNodeElement = getParentNodeElement(nodeElement);
    return parentNodeElement ? parentNodeElement.nextElementSibling || findNextSiblingOfAncestor2(parentNodeElement) : null;
  };
  var findLastVisibleDescendant = function findLastVisibleDescendant2(nodeElement) {
    var childrenListElement = nodeElement.children[1];
    if (childrenListElement) {
      var lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
      return findLastVisibleDescendant2(lastChildElement);
    } else {
      return nodeElement;
    }
  };
  var getParentNodeElement = function getParentNodeElement2(nodeElement) {
    var parentNodeElement = nodeElement.parentElement.parentElement;
    return DomHandler.hasClass(parentNodeElement, "p-treenode") ? parentNodeElement : null;
  };
  var focusNode = function focusNode2(element) {
    element && element.focus();
  };
  var onClick = function onClick2(event) {
    if (props.onClick) {
      props.onClick({
        originalEvent: event,
        node: props.node
      });
    }
    var targetNode = event.target.nodeName;
    if (props.disabled || targetNode === "INPUT" || targetNode === "BUTTON" || targetNode === "A" || DomHandler.hasClass(event.target, "p-clickable")) {
      return;
    }
    if (props.selectionMode && props.node.selectable !== false) {
      var selectionKeys;
      if (isCheckboxSelectionMode()) {
        var checked = isChecked();
        selectionKeys = props.selectionKeys ? _objectSpread$1({}, props.selectionKeys) : {};
        if (checked) {
          if (props.propagateSelectionDown)
            propagateDown(props.node, false, selectionKeys);
          else
            delete selectionKeys[props.node.key];
          if (props.propagateSelectionUp && props.onPropagateUp) {
            props.onPropagateUp({
              originalEvent: event,
              check: false,
              selectionKeys
            });
          }
          if (props.onUnselect) {
            props.onUnselect({
              originalEvent: event,
              node: props.node
            });
          }
        } else {
          if (props.propagateSelectionDown)
            propagateDown(props.node, true, selectionKeys);
          else
            selectionKeys[props.node.key] = {
              checked: true
            };
          if (props.propagateSelectionUp && props.onPropagateUp) {
            props.onPropagateUp({
              originalEvent: event,
              check: true,
              selectionKeys
            });
          }
          if (props.onSelect) {
            props.onSelect({
              originalEvent: event,
              node: props.node
            });
          }
        }
      } else {
        var selected = isSelected();
        var metaSelection = nodeTouched.current ? false : props.metaKeySelection;
        if (metaSelection) {
          var metaKey = event.metaKey || event.ctrlKey;
          if (selected && metaKey) {
            if (isSingleSelectionMode()) {
              selectionKeys = null;
            } else {
              selectionKeys = _objectSpread$1({}, props.selectionKeys);
              delete selectionKeys[props.node.key];
            }
            if (props.onUnselect) {
              props.onUnselect({
                originalEvent: event,
                node: props.node
              });
            }
          } else {
            if (isSingleSelectionMode()) {
              selectionKeys = props.node.key;
            } else if (isMultipleSelectionMode()) {
              selectionKeys = !metaKey ? {} : props.selectionKeys ? _objectSpread$1({}, props.selectionKeys) : {};
              selectionKeys[props.node.key] = true;
            }
            if (props.onSelect) {
              props.onSelect({
                originalEvent: event,
                node: props.node
              });
            }
          }
        } else {
          if (isSingleSelectionMode()) {
            if (selected) {
              selectionKeys = null;
              if (props.onUnselect) {
                props.onUnselect({
                  originalEvent: event,
                  node: props.node
                });
              }
            } else {
              selectionKeys = props.node.key;
              if (props.onSelect) {
                props.onSelect({
                  originalEvent: event,
                  node: props.node
                });
              }
            }
          } else {
            if (selected) {
              selectionKeys = _objectSpread$1({}, props.selectionKeys);
              delete selectionKeys[props.node.key];
              if (props.onUnselect) {
                props.onUnselect({
                  originalEvent: event,
                  node: props.node
                });
              }
            } else {
              selectionKeys = props.selectionKeys ? _objectSpread$1({}, props.selectionKeys) : {};
              selectionKeys[props.node.key] = true;
              if (props.onSelect) {
                props.onSelect({
                  originalEvent: event,
                  node: props.node
                });
              }
            }
          }
        }
      }
      if (props.onSelectionChange) {
        props.onSelectionChange({
          originalEvent: event,
          value: selectionKeys
        });
      }
    }
    nodeTouched.current = false;
  };
  var onDoubleClick = function onDoubleClick2(event) {
    if (props.onDoubleClick) {
      props.onDoubleClick({
        originalEvent: event,
        node: props.node
      });
    }
  };
  var onRightClick = function onRightClick2(event) {
    if (props.disabled) {
      return;
    }
    DomHandler.clearSelection();
    if (props.onContextMenuSelectionChange) {
      props.onContextMenuSelectionChange({
        originalEvent: event,
        value: props.node.key
      });
    }
    if (props.onContextMenu) {
      props.onContextMenu({
        originalEvent: event,
        node: props.node
      });
    }
  };
  var onKeyDown = function onKeyDown2(event) {
    if (!isSameNode(event))
      return;
    switch (event.code) {
      case "Tab":
        onTabKey();
        break;
      case "ArrowDown":
        onArrowDown(event);
        break;
      case "ArrowUp":
        onArrowUp(event);
        break;
      case "ArrowRight":
        onArrowRight(event);
        break;
      case "ArrowLeft":
        onArrowLeft(event);
        break;
      case "Enter":
      case "NumpadEnter":
      case "Space":
        onEnterKey(event);
        break;
    }
  };
  var onArrowDown = function onArrowDown2(event) {
    var nodeElement = event.target.getAttribute("data-pc-section") === "toggler" ? event.target.closest('[role="treeitem"]') : event.target;
    var listElement = nodeElement.children[1];
    if (listElement) {
      focusRowChange(nodeElement, listElement.children[0]);
    } else {
      if (nodeElement.nextElementSibling) {
        focusRowChange(nodeElement, nodeElement.nextElementSibling);
      } else {
        var nextSiblingAncestor = findNextSiblingOfAncestor(nodeElement);
        if (nextSiblingAncestor) {
          focusRowChange(nodeElement, nextSiblingAncestor);
        }
      }
    }
    event.preventDefault();
  };
  var onArrowUp = function onArrowUp2(event) {
    var nodeElement = event.target;
    if (nodeElement.previousElementSibling) {
      focusRowChange(nodeElement, nodeElement.previousElementSibling, findLastVisibleDescendant(nodeElement.previousElementSibling));
    } else {
      var parentNodeElement = getParentNodeElement(nodeElement);
      if (parentNodeElement) {
        focusRowChange(nodeElement, parentNodeElement);
      }
    }
    event.preventDefault();
  };
  var onArrowRight = function onArrowRight2(event) {
    if (isLeaf || expanded)
      return;
    event.currentTarget.tabIndex = -1;
    expand(event, true);
  };
  var onArrowLeft = function onArrowLeft2(event) {
    var togglerElement = DomHandler.findSingle(event.currentTarget, '[data-pc-section="toggler"]');
    if (props.level === 0 && !expanded) {
      return false;
    }
    if (expanded && !isLeaf) {
      togglerElement.click();
      return false;
    }
    var target = findBeforeClickableNode(event.currentTarget);
    if (target) {
      focusRowChange(event.currentTarget, target);
    }
  };
  var onEnterKey = function onEnterKey2(event) {
    setTabIndexForSelectionMode(event, nodeTouched.current);
    onClick(event);
    event.preventDefault();
  };
  var onTabKey = function onTabKey2() {
    setAllNodesTabIndexes();
  };
  var setAllNodesTabIndexes = function setAllNodesTabIndexes2() {
    var nodes = DomHandler.find(contentRef.current.closest('[data-pc-section="container"]'), '[role="treeitem"]');
    var hasSelectedNode = _toConsumableArray(nodes).some(function(node3) {
      return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
    });
    _toConsumableArray(nodes).forEach(function(node3) {
      node3.tabIndex = -1;
    });
    if (hasSelectedNode) {
      var selectedNodes = _toConsumableArray(nodes).filter(function(node3) {
        return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
      });
      selectedNodes[0].tabIndex = 0;
      return;
    }
    _toConsumableArray(nodes)[0].tabIndex = 0;
  };
  var setTabIndexForSelectionMode = function setTabIndexForSelectionMode2(event, nodeTouched2) {
    if (props.selectionMode !== null) {
      var elements = _toConsumableArray(DomHandler.find(elementRef.current.parentElement, '[role="treeitem"]'));
      event.currentTarget.tabIndex = nodeTouched2 === false ? -1 : 0;
      if (elements.every(function(element) {
        return element.tabIndex === -1;
      })) {
        elements[0].tabIndex = 0;
      }
    }
  };
  var focusRowChange = function focusRowChange2(firstFocusableRow, currentFocusedRow, lastVisibleDescendant) {
    firstFocusableRow.tabIndex = "-1";
    currentFocusedRow.tabIndex = "0";
    focusNode(lastVisibleDescendant || currentFocusedRow);
  };
  var findBeforeClickableNode = function findBeforeClickableNode2(node3) {
    var parentListElement = node3.closest("ul").closest("li");
    if (parentListElement) {
      var prevNodeButton = DomHandler.findSingle(parentListElement, "button");
      if (prevNodeButton && prevNodeButton.style.visibility !== "hidden") {
        return parentListElement;
      }
      return findBeforeClickableNode2(node3.previousElementSibling);
    }
    return null;
  };
  var propagateUp = function propagateUp2(event) {
    var check = event.check;
    var selectionKeys = event.selectionKeys;
    var checkedChildCount = 0;
    var _iterator = _createForOfIteratorHelper$1(props.node.children), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var child = _step.value;
        if (selectionKeys[child.key] && selectionKeys[child.key].checked)
          checkedChildCount++;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var parentKey = props.node.key;
    var children = ObjectUtils.findChildrenByKey(props.originalOptions, parentKey);
    var isParentPartiallyChecked = children.some(function(ele) {
      return ele.key in selectionKeys;
    });
    var isCompletelyChecked = children.every(function(ele) {
      return ele.key in selectionKeys && selectionKeys[ele.key].checked;
    });
    if (isParentPartiallyChecked && !isCompletelyChecked) {
      selectionKeys[parentKey] = {
        checked: false,
        partialChecked: true
      };
    } else if (isCompletelyChecked) {
      selectionKeys[parentKey] = {
        checked: true,
        partialChecked: false
      };
    } else if (check) {
      selectionKeys[parentKey] = {
        checked: false,
        partialChecked: false
      };
    } else {
      delete selectionKeys[parentKey];
    }
    if (props.propagateSelectionUp && props.onPropagateUp) {
      props.onPropagateUp(event);
    }
  };
  var propagateDown = function propagateDown2(node3, check, selectionKeys) {
    if (check)
      selectionKeys[node3.key] = {
        checked: true,
        partialChecked: false
      };
    else
      delete selectionKeys[node3.key];
    if (node3.children && node3.children.length) {
      for (var i = 0; i < node3.children.length; i++) {
        propagateDown2(node3.children[i], check, selectionKeys);
      }
    }
  };
  var isSelected = function isSelected2() {
    if (props.selectionMode && props.selectionKeys)
      return isSingleSelectionMode() ? props.selectionKeys === props.node.key : props.selectionKeys[props.node.key] !== void 0;
    else
      return false;
  };
  var isChecked = function isChecked2() {
    return (props.selectionKeys ? props.selectionKeys[props.node.key] && props.selectionKeys[props.node.key].checked : false) || false;
  };
  var isSameNode = function isSameNode2(event) {
    return event.currentTarget && (event.currentTarget.isSameNode(event.target) || event.currentTarget.isSameNode(event.target.closest('[role="treeitem"]')));
  };
  var isPartialChecked = function isPartialChecked2() {
    return props.selectionKeys ? props.selectionKeys[props.node.key] && props.selectionKeys[props.node.key].partialChecked : false;
  };
  var isSingleSelectionMode = function isSingleSelectionMode2() {
    return props.selectionMode && props.selectionMode === "single";
  };
  var isMultipleSelectionMode = function isMultipleSelectionMode2() {
    return props.selectionMode && props.selectionMode === "multiple";
  };
  var isCheckboxSelectionMode = function isCheckboxSelectionMode2() {
    return props.selectionMode && props.selectionMode === "checkbox";
  };
  var onTouchEnd = function onTouchEnd2() {
    nodeTouched.current = true;
  };
  var onDropPoint = function onDropPoint2(event, position) {
    event.preventDefault();
    if (props.node.droppable !== false) {
      DomHandler.removeClass(event.target, "p-treenode-droppoint-active");
      if (props.onDropPoint) {
        var dropIndex = position === -1 ? props.index : props.index + 1;
        props.onDropPoint({
          originalEvent: event,
          path: props.path,
          index: dropIndex,
          position
        });
      }
    }
  };
  var onDropPointDragOver = function onDropPointDragOver2(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase()) {
      event.dataTransfer.dropEffect = "move";
      event.preventDefault();
    }
  };
  var onDropPointDragEnter = function onDropPointDragEnter2(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase()) {
      DomHandler.addClass(event.target, "p-treenode-droppoint-active");
    }
  };
  var onDropPointDragLeave = function onDropPointDragLeave2(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase()) {
      DomHandler.removeClass(event.target, "p-treenode-droppoint-active");
    }
  };
  var onDrop = function onDrop2(event) {
    if (props.dragdropScope && props.node.droppable !== false) {
      DomHandler.removeClass(contentRef.current, "p-treenode-dragover");
      event.preventDefault();
      event.stopPropagation();
      if (props.onDrop) {
        props.onDrop({
          originalEvent: event,
          path: props.path,
          index: props.index
        });
      }
    }
  };
  var onDragOver = function onDragOver2(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase() && props.node.droppable !== false) {
      event.dataTransfer.dropEffect = "move";
      event.preventDefault();
      event.stopPropagation();
    }
  };
  var onDragEnter = function onDragEnter2(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase() && props.node.droppable !== false) {
      DomHandler.addClass(contentRef.current, "p-treenode-dragover");
    }
  };
  var onDragLeave = function onDragLeave2(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase() && props.node.droppable !== false) {
      var rect = event.currentTarget.getBoundingClientRect();
      if (event.nativeEvent.x > rect.left + rect.width || event.nativeEvent.x < rect.left || event.nativeEvent.y >= Math.floor(rect.top + rect.height) || event.nativeEvent.y < rect.top) {
        DomHandler.removeClass(contentRef.current, "p-treenode-dragover");
      }
    }
  };
  var onDragStart = function onDragStart2(event) {
    event.dataTransfer.setData("text", props.dragdropScope);
    event.dataTransfer.setData(props.dragdropScope, props.dragdropScope);
    if (props.onDragStart) {
      props.onDragStart({
        originalEvent: event,
        path: props.path,
        index: props.index
      });
    }
  };
  var onDragEnd = function onDragEnd2(event) {
    if (props.onDragEnd) {
      props.onDragEnd({
        originalEvent: event
      });
    }
  };
  var createLabel = function createLabel2() {
    var labelProps = mergeProps({
      className: cx("label")
    }, getPTOptions("label"));
    var content2 = React2.createElement("span", labelProps, label2);
    if (props.nodeTemplate) {
      var defaultContentOptions = {
        onTogglerClick,
        className: "p-treenode-label",
        element: content2,
        props,
        expanded
      };
      content2 = ObjectUtils.getJSXElement(props.nodeTemplate, props.node, defaultContentOptions);
    }
    return content2;
  };
  var createCheckbox = function createCheckbox2() {
    if (isCheckboxSelectionMode() && props.node.selectable !== false) {
      var checked = isChecked();
      var partialChecked = isPartialChecked();
      var checkboxIconProps = mergeProps({
        className: cx("checkboxIcon")
      }, getPTOptions("checkboxIcon"));
      var icon = checked ? props.checkboxIcon || React2.createElement(CheckIcon, checkboxIconProps) : partialChecked ? props.checkboxIcon || React2.createElement(MinusIcon, checkboxIconProps) : null;
      var checkboxIcon = IconUtils.getJSXIcon(icon, _objectSpread$1({}, checkboxIconProps), props);
      var checkboxContainerProps = mergeProps({
        "aria-hidden": true,
        className: cx("checkboxContainer")
      }, getPTOptions("checkboxContainer"));
      var checkboxProps = mergeProps({
        className: cx("checkbox", {
          checked,
          partialChecked,
          nodeProps: props
        }),
        role: "checkbox"
      }, getPTOptions("checkbox"));
      return React2.createElement("div", checkboxContainerProps, React2.createElement("div", checkboxProps, checkboxIcon));
    }
    return null;
  };
  var createIcon = function createIcon2() {
    var icon = props.node.icon || (expanded ? props.node.expandedIcon : props.node.collapsedIcon);
    if (icon) {
      var nodeIconProps = mergeProps({
        className: classNames(icon, cx("nodeIcon"))
      }, getPTOptions("nodeIcon"));
      return React2.createElement("span", nodeIconProps);
    }
    return null;
  };
  var createToggler = function createToggler2() {
    var togglerIconProps = mergeProps({
      className: cx("togglerIcon"),
      "aria-hidden": true
    }, getPTOptions("togglerIcon"));
    var icon = expanded ? props.collapseIcon || React2.createElement(ChevronDownIcon, togglerIconProps) : props.expandIcon || React2.createElement(ChevronRightIcon, togglerIconProps);
    var togglerIcon = IconUtils.getJSXIcon(icon, _objectSpread$1({}, togglerIconProps), {
      props,
      expanded
    });
    var togglerProps = mergeProps({
      type: "button",
      className: cx("toggler"),
      tabIndex: -1,
      "aria-hidden": true,
      onClick: onTogglerClick
    }, getPTOptions("toggler"));
    var content2 = React2.createElement("button", togglerProps, togglerIcon, React2.createElement(Ripple, null));
    if (props.togglerTemplate) {
      var defaultContentOptions = {
        onClick: onTogglerClick,
        containerClassName: "p-tree-toggler p-link",
        iconClassName: "p-tree-toggler-icon",
        element: content2,
        props,
        expanded
      };
      content2 = ObjectUtils.getJSXElement(props.togglerTemplate, props.node, defaultContentOptions);
    }
    return content2;
  };
  var createDropPoint = function createDropPoint2(position) {
    if (props.dragdropScope) {
      var droppointProps = mergeProps({
        className: cx("droppoint"),
        onDrop: function onDrop2(event) {
          return onDropPoint(event, position);
        },
        onDragOver: onDropPointDragOver,
        onDragEnter: onDropPointDragEnter,
        onDragLeave: onDropPointDragLeave
      }, getPTOptions("droppoint"));
      return React2.createElement("li", droppointProps);
    }
    return null;
  };
  var createContent = function createContent2() {
    var selected = isSelected();
    var checked = isChecked();
    var toggler = createToggler();
    var checkbox2 = createCheckbox();
    var icon = createIcon();
    var label3 = createLabel();
    var contentProps = mergeProps({
      ref: contentRef,
      className: classNames(props.node.className, cx("content", {
        checked,
        selected,
        nodeProps: props,
        isCheckboxSelectionMode
      })),
      style: props.node.style,
      onClick,
      onDoubleClick,
      onContextMenu: onRightClick,
      onTouchEnd,
      draggable: props.dragdropScope && props.node.draggable !== false && !props.disabled,
      onDrop,
      onDragOver,
      onDragEnter,
      onDragLeave,
      onDragStart,
      onDragEnd,
      "data-p-highlight": isCheckboxSelectionMode() ? checked : selected
    }, getPTOptions("content"));
    return React2.createElement("div", contentProps, toggler, checkbox2, icon, label3);
  };
  var createChildren = function createChildren2() {
    var subgroupProps = mergeProps({
      className: cx("subgroup"),
      role: "group"
    }, getPTOptions("subgroup"));
    if (ObjectUtils.isNotEmpty(props.node.children) && expanded) {
      return React2.createElement("ul", subgroupProps, props.node.children.map(function(childNode, index) {
        return React2.createElement(UITreeNode, {
          key: childNode.key || childNode.label,
          node: childNode,
          checkboxIcon: props.checkboxIcon,
          collapseIcon: props.collapseIcon,
          contextMenuSelectionKey: props.contextMenuSelectionKey,
          cx,
          disabled: props.disabled,
          dragdropScope: props.dragdropScope,
          expandIcon: props.expandIcon,
          expandedKeys: props.expandedKeys,
          index,
          isNodeLeaf: props.isNodeLeaf,
          last: index === props.node.children.length - 1,
          metaKeySelection: props.metaKeySelection,
          nodeTemplate: props.nodeTemplate,
          onClick: props.onClick,
          onCollapse: props.onCollapse,
          onContextMenu: props.onContextMenu,
          onContextMenuSelectionChange: props.onContextMenuSelectionChange,
          onDoubleClick: props.onDoubleClick,
          onDragEnd: props.onDragEnd,
          onDragStart: props.onDragStart,
          onDrop: props.onDrop,
          onDropPoint: props.onDropPoint,
          onExpand: props.onExpand,
          onPropagateUp: propagateUp,
          onSelect: props.onSelect,
          onSelectionChange: props.onSelectionChange,
          onToggle: props.onToggle,
          onUnselect: props.onUnselect,
          originalOptions: props.originalOptions,
          parent: props.node,
          path: props.path + "-" + index,
          propagateSelectionDown: props.propagateSelectionDown,
          propagateSelectionUp: props.propagateSelectionUp,
          ptm,
          selectionKeys: props.selectionKeys,
          selectionMode: props.selectionMode,
          togglerTemplate: props.togglerTemplate
        });
      }));
    }
    return null;
  };
  var createNode = function createNode2() {
    var tabIndex = props.disabled || props.index !== 0 ? -1 : 0;
    var selected = isSelected();
    var checked = isChecked();
    var content2 = createContent();
    var children = createChildren();
    var nodeProps = mergeProps(_defineProperty(_defineProperty({
      ref: elementRef,
      className: classNames(props.node.className, cx("node", {
        isLeaf
      })),
      style: props.node.style,
      tabIndex,
      role: "treeitem",
      "aria-label": label2,
      "aria-level": props.level,
      "aria-expanded": expanded,
      "aria-checked": checked,
      "aria-setsize": props.node.children ? props.node.children.length : 0,
      "aria-posinset": props.index + 1,
      onKeyDown
    }, "aria-expanded", expanded), "aria-selected", checked || selected), getPTOptions("node"));
    return React2.createElement("li", nodeProps, content2, children);
  };
  var node2 = createNode();
  if (props.dragdropScope && !props.disabled) {
    var beforeDropPoint = createDropPoint(-1);
    var afterDropPoint = props.last ? createDropPoint(1) : null;
    return React2.createElement(React2.Fragment, null, beforeDropPoint, node2, afterDropPoint);
  }
  return node2;
});
UITreeNode.displayName = "UITreeNode";
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var Tree = React2.memo(React2.forwardRef(function(inProps, ref) {
  var mergeProps = useMergeProps();
  var context = React2.useContext(PrimeReactContext);
  var props = TreeBase.getProps(inProps, context);
  var _React$useState = React2.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), filterValueState = _React$useState2[0], setFilterValueState = _React$useState2[1];
  var _React$useState3 = React2.useState(props.expandedKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), expandedKeysState = _React$useState4[0], setExpandedKeysState = _React$useState4[1];
  var elementRef = React2.useRef(null);
  var filteredNodes = React2.useRef([]);
  var dragState = React2.useRef(null);
  var filterChanged = React2.useRef(false);
  var filteredValue = props.onFilterValueChange ? props.filterValue : filterValueState;
  var expandedKeys = props.onToggle ? props.expandedKeys : expandedKeysState;
  var childFocusEvent = React2.useRef(null);
  var _TreeBase$setMetaData = TreeBase.setMetaData({
    props,
    state: {
      filterValue: filteredValue,
      expandedKeys
    }
  }), ptm = _TreeBase$setMetaData.ptm, cx = _TreeBase$setMetaData.cx, isUnstyled = _TreeBase$setMetaData.isUnstyled;
  useHandleStyle(TreeBase.css.styles, isUnstyled, {
    name: "tree"
  });
  var filterOptions = {
    filter: function filter2(e) {
      return onFilterInputChange(e);
    },
    reset: function reset() {
      return resetFilter();
    }
  };
  var getRootNode = function getRootNode2() {
    return props.filter && filteredNodes.current ? filteredNodes.current : props.value;
  };
  var onToggle = function onToggle2(event) {
    var originalEvent = event.originalEvent, value = event.value, navigateFocusToChild = event.navigateFocusToChild;
    if (props.onToggle) {
      props.onToggle({
        originalEvent,
        value
      });
    } else {
      if (navigateFocusToChild) {
        childFocusEvent.current = originalEvent;
      }
      setExpandedKeysState(value);
    }
  };
  useUpdateEffect2(function() {
    if (childFocusEvent.current) {
      var event = childFocusEvent.current;
      var nodeElement = event.target.getAttribute("data-pc-section") === "toggler" ? event.target.closest('[role="treeitem"]') : event.target;
      var listElement = nodeElement.children[1];
      var childElement = listElement.children[0];
      nodeElement.tabIndex = "-1";
      childElement.tabIndex = "0";
      childElement.focus();
      childFocusEvent.current = null;
    }
  }, [expandedKeys]);
  var onDragStart = function onDragStart2(event) {
    dragState.current = {
      path: event.path,
      index: event.index
    };
  };
  var onDragEnd = function onDragEnd2() {
    dragState.current = null;
  };
  var cloneValue = function cloneValue2(value) {
    if (Array.isArray(value)) {
      return value.map(cloneValue2);
    } else if (!!value && Object.getPrototypeOf(value) === Object.prototype) {
      var result = {};
      for (var key in value) {
        if (key !== "data") {
          result[key] = cloneValue2(value[key]);
        } else {
          result[key] = value[key];
        }
      }
      return result;
    } else
      return value;
  };
  var onDrop = function onDrop2(event) {
    if (validateDropNode(dragState.current.path, event.path)) {
      var value = cloneValue(props.value);
      var dragPaths = dragState.current.path.split("-");
      dragPaths.pop();
      var dragNodeParent = findNode(value, dragPaths);
      var dragNode = dragNodeParent ? dragNodeParent.children[dragState.current.index] : value[dragState.current.index];
      var dropNode = findNode(value, event.path.split("-"));
      if (dropNode.children)
        dropNode.children.push(dragNode);
      else
        dropNode.children = [dragNode];
      if (dragNodeParent)
        dragNodeParent.children.splice(dragState.current.index, 1);
      else
        value.splice(dragState.current.index, 1);
      if (props.onDragDrop) {
        props.onDragDrop({
          originalEvent: event.originalEvent,
          value,
          dragNode,
          dropNode,
          dropIndex: event.index
        });
      }
    }
  };
  var onDropPoint = function onDropPoint2(event) {
    if (validateDropPoint(event)) {
      var value = cloneValue(props.value);
      var dragPaths = dragState.current.path.split("-");
      dragPaths.pop();
      var dropPaths = event.path.split("-");
      dropPaths.pop();
      var dragNodeParent = findNode(value, dragPaths);
      var dropNodeParent = findNode(value, dropPaths);
      var dragNode = dragNodeParent ? dragNodeParent.children[dragState.current.index] : value[dragState.current.index];
      var siblings = areSiblings(dragState.current.path, event.path);
      if (dragNodeParent)
        dragNodeParent.children.splice(dragState.current.index, 1);
      else
        value.splice(dragState.current.index, 1);
      if (event.position < 0) {
        var dropIndex = siblings ? dragState.current.index > event.index ? event.index : event.index - 1 : event.index;
        if (dropNodeParent)
          dropNodeParent.children.splice(dropIndex, 0, dragNode);
        else
          value.splice(dropIndex, 0, dragNode);
      } else {
        if (dropNodeParent)
          dropNodeParent.children.push(dragNode);
        else
          value.push(dragNode);
      }
      if (props.onDragDrop) {
        props.onDragDrop({
          originalEvent: event.originalEvent,
          value,
          dragNode,
          dropNode: dropNodeParent,
          dropIndex: event.index
        });
      }
    }
  };
  var validateDrop = function validateDrop2(dragPath, dropPath) {
    if (!dragPath) {
      return false;
    } else {
      if (dragPath === dropPath) {
        return false;
      }
      if (dropPath.indexOf(dragPath) === 0) {
        return false;
      }
      return true;
    }
  };
  var validateDropNode = function validateDropNode2(dragPath, dropPath) {
    var _validateDrop = validateDrop(dragPath, dropPath);
    if (_validateDrop) {
      if (dragPath.indexOf("-") > 0 && dragPath.substring(0, dragPath.lastIndexOf("-")) === dropPath) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  };
  var validateDropPoint = function validateDropPoint2(event) {
    var _validateDrop = validateDrop(dragState.current.path, event.path);
    if (_validateDrop) {
      if (event.position === -1 && areSiblings(dragState.current.path, event.path) && dragState.current.index + 1 === event.index) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  };
  var areSiblings = function areSiblings2(path1, path2) {
    if (path1.length === 1 && path2.length === 1)
      return true;
    else
      return path1.substring(0, path1.lastIndexOf("-")) === path2.substring(0, path2.lastIndexOf("-"));
  };
  var findNode = function findNode2(value, path) {
    if (path.length === 0) {
      return null;
    } else {
      var index = parseInt(path[0], 10);
      var nextSearchRoot = value.children ? value.children[index] : value[index];
      if (path.length === 1) {
        return nextSearchRoot;
      } else {
        path.shift();
        return findNode2(nextSearchRoot, path);
      }
    }
  };
  var isNodeLeaf = function isNodeLeaf2(node2) {
    return node2.leaf === false ? false : !(node2.children && node2.children.length);
  };
  var onFilterInputKeyDown = function onFilterInputKeyDown2(event) {
    if (event.which === 13) {
      event.preventDefault();
    }
  };
  var onFilterInputChange = function onFilterInputChange2(event) {
    filterChanged.current = true;
    var value = event.target.value;
    if (props.onFilterValueChange) {
      props.onFilterValueChange({
        originalEvent: event,
        value
      });
    } else {
      setFilterValueState(value);
    }
  };
  var filter = function filter2(value) {
    setFilterValueState(ObjectUtils.isNotEmpty(value) ? value : "");
    _filter();
  };
  var _filter = function _filter2() {
    if (!filterChanged.current) {
      return;
    }
    if (ObjectUtils.isEmpty(filteredValue)) {
      filteredNodes.current = props.value;
    } else {
      filteredNodes.current = [];
      var searchFields = props.filterBy.split(",");
      var filterText = filteredValue.toLocaleLowerCase(props.filterLocale);
      var isStrictMode = props.filterMode === "strict";
      var _iterator = _createForOfIteratorHelper(props.value), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var node2 = _step.value;
          var copyNode = _objectSpread({}, node2);
          var paramsWithoutNode = {
            searchFields,
            filterText,
            isStrictMode
          };
          if (isStrictMode && (findFilteredNodes(copyNode, paramsWithoutNode) || isFilterMatched(copyNode, paramsWithoutNode)) || !isStrictMode && (isFilterMatched(copyNode, paramsWithoutNode) || findFilteredNodes(copyNode, paramsWithoutNode))) {
            filteredNodes.current.push(copyNode);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    filterChanged.current = false;
  };
  var findFilteredNodes = function findFilteredNodes2(node2, paramsWithoutNode) {
    if (node2) {
      var matched = false;
      if (node2.children) {
        var childNodes = _toConsumableArray(node2.children);
        node2.children = [];
        var _iterator2 = _createForOfIteratorHelper(childNodes), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var childNode = _step2.value;
            var copyChildNode = _objectSpread({}, childNode);
            if (isFilterMatched(copyChildNode, paramsWithoutNode)) {
              matched = true;
              node2.children.push(copyChildNode);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      if (matched) {
        node2.expanded = true;
        return true;
      }
    }
  };
  var isFilterMatched = function isFilterMatched2(node2, _ref) {
    var searchFields = _ref.searchFields, filterText = _ref.filterText, isStrictMode = _ref.isStrictMode;
    var matched = false;
    var _iterator3 = _createForOfIteratorHelper(searchFields), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var field = _step3.value;
        var fieldValue = String(ObjectUtils.resolveFieldData(node2, field)).toLocaleLowerCase(props.filterLocale);
        if (fieldValue.indexOf(filterText) > -1) {
          matched = true;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    if (!matched || isStrictMode && !isNodeLeaf(node2)) {
      matched = findFilteredNodes(node2, {
        searchFields,
        filterText,
        isStrictMode
      }) || matched;
    }
    return matched;
  };
  var resetFilter = function resetFilter2() {
    setFilterValueState("");
  };
  React2.useImperativeHandle(ref, function() {
    return {
      props,
      filter,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var createRootChild = function createRootChild2(node2, index, last) {
    return React2.createElement(UITreeNode, {
      hostName: "Tree",
      key: node2.key || node2.label,
      node: node2,
      level: props.level + 1,
      originalOptions: props.value,
      index,
      last,
      path: String(index),
      checkboxIcon: props.checkboxIcon,
      collapseIcon: props.collapseIcon,
      contextMenuSelectionKey: props.contextMenuSelectionKey,
      cx,
      disabled: props.disabled,
      dragdropScope: props.dragdropScope,
      expandIcon: props.expandIcon,
      expandedKeys,
      isNodeLeaf,
      metaKeySelection: props.metaKeySelection,
      nodeTemplate: props.nodeTemplate,
      onClick: props.onNodeClick,
      onCollapse: props.onCollapse,
      onContextMenu: props.onContextMenu,
      onContextMenuSelectionChange: props.onContextMenuSelectionChange,
      onDoubleClick: props.onNodeDoubleClick,
      onDragEnd,
      onDragStart,
      onDrop,
      onDropPoint,
      onExpand: props.onExpand,
      onSelect: props.onSelect,
      onSelectionChange: props.onSelectionChange,
      onToggle,
      onUnselect: props.onUnselect,
      propagateSelectionDown: props.propagateSelectionDown,
      propagateSelectionUp: props.propagateSelectionUp,
      ptm,
      selectionKeys: props.selectionKeys,
      selectionMode: props.selectionMode,
      togglerTemplate: props.togglerTemplate
    });
  };
  var createRootChildren = function createRootChildren2() {
    if (props.filter) {
      filterChanged.current = true;
      _filter();
    }
    var value = getRootNode();
    return value.map(function(node2, index) {
      return createRootChild(node2, index, index === value.length - 1);
    });
  };
  var createModel = function createModel2() {
    if (props.value) {
      var rootNodes = createRootChildren();
      var containerProps = mergeProps(_objectSpread({
        className: classNames(props.contentClassName, cx("container")),
        role: "tree",
        "aria-label": props.ariaLabel,
        "aria-labelledby": props.ariaLabelledBy,
        style: props.contentStyle
      }, ariaProps), ptm("container"));
      return React2.createElement("ul", containerProps, rootNodes);
    }
    return null;
  };
  var createLoader = function createLoader2() {
    if (props.loading) {
      var loadingIconProps = mergeProps({
        className: cx("loadingIcon")
      }, ptm("loadingIcon"));
      var icon = props.loadingIcon || React2.createElement(SpinnerIcon, _extends2({}, loadingIconProps, {
        spin: true
      }));
      var loadingIcon = IconUtils.getJSXIcon(icon, _objectSpread({}, loadingIconProps), {
        props
      });
      var loadingOverlayProps = mergeProps({
        className: cx("loadingOverlay")
      }, ptm("loadingOverlay"));
      return React2.createElement("div", loadingOverlayProps, loadingIcon);
    }
    return null;
  };
  var createFilter = function createFilter2() {
    if (props.filter) {
      var value = ObjectUtils.isNotEmpty(filteredValue) ? filteredValue : "";
      var searchIconProps = mergeProps({
        className: cx("searchIcon")
      }, ptm("searchIcon"));
      var icon = props.filterIcon || React2.createElement(SearchIcon, searchIconProps);
      var filterIcon = IconUtils.getJSXIcon(icon, _objectSpread({}, searchIconProps), {
        props
      });
      var filterContainerProps = mergeProps({
        className: cx("filterContainer")
      }, ptm("filterContainer"));
      var inputProps = mergeProps({
        type: "text",
        value,
        autoComplete: "off",
        className: cx("input"),
        placeholder: props.filterPlaceholder,
        "aria-label": props.filterPlaceholder,
        onKeyDown: onFilterInputKeyDown,
        onChange: onFilterInputChange,
        disabled: props.disabled
      }, ptm("input"));
      var _content = React2.createElement("div", filterContainerProps, React2.createElement("input", inputProps), filterIcon);
      if (props.filterTemplate) {
        var defaultContentOptions = {
          className: "p-tree-filter-container",
          element: _content,
          filterOptions,
          filterInputKeyDown: onFilterInputKeyDown,
          filterInputChange: onFilterInputChange,
          filterIconClassName: "p-dropdown-filter-icon",
          props
        };
        _content = ObjectUtils.getJSXElement(props.filterTemplate, defaultContentOptions);
      }
      return React2.createElement(React2.Fragment, null, _content);
    }
    return null;
  };
  var createHeader = function createHeader2() {
    if (props.showHeader) {
      var filterElement = createFilter();
      var _content2 = filterElement;
      if (props.header) {
        var defaultContentOptions = {
          filterContainerClassName: "p-tree-filter-container",
          filterIconClassName: "p-tree-filter-icon",
          filterInput: {
            className: "p-tree-filter p-inputtext p-component",
            onKeyDown: onFilterInputKeyDown,
            onChange: onFilterInputChange
          },
          filterElement,
          element: _content2,
          props
        };
        _content2 = ObjectUtils.getJSXElement(props.header, defaultContentOptions);
      }
      var headerProps = mergeProps({
        className: cx("header")
      }, ptm("header"));
      return React2.createElement("div", headerProps, _content2);
    }
    return null;
  };
  var createFooter = function createFooter2() {
    var content3 = ObjectUtils.getJSXElement(props.footer, props);
    var footerProps = mergeProps({
      className: cx("footer")
    }, ptm("footer"));
    return React2.createElement("div", footerProps, content3);
  };
  var otherProps = TreeBase.getOtherProps(props);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var loader = createLoader();
  var content2 = createModel();
  var header = createHeader();
  var footer = createFooter();
  var rootProps = mergeProps({
    ref: elementRef,
    className: classNames(props.className, cx("root")),
    style: props.style,
    id: props.id
  }, TreeBase.getOtherProps(props), ptm("root"));
  return React2.createElement("div", rootProps, loader, header, content2, footer);
}));
Tree.displayName = "Tree";

// node_modules/primereact/treeselect/treeselect.esm.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _arrayLikeToArray$12(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$12(arr);
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$12(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$12(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$12(o, minLen);
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray$12(arr) || _nonIterableSpread2();
}
function _typeof2(o) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof2(o);
}
function _toPrimitive2(input, hint) {
  if (_typeof2(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof2(key) === "symbol" ? key : String(key);
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit2(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t)
          return;
        f = false;
      } else
        for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
          ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray$12(arr, i) || _nonIterableRest2();
}
var classes2 = {
  root: function root2(_ref) {
    var props = _ref.props, focusedState = _ref.focusedState, overlayVisibleState = _ref.overlayVisibleState, isValueEmpty = _ref.isValueEmpty;
    return classNames("p-treeselect p-component p-inputwrapper", {
      "p-treeselect-chip": props.display === "chip",
      "p-treeselect-clearable": props.showClear && !props.disabled,
      "p-disabled": props.disabled,
      "p-focus": focusedState,
      "p-inputwrapper-filled": !isValueEmpty,
      "p-inputwrapper-focus": focusedState || overlayVisibleState
    }, props.className);
  },
  label: function label(_ref2) {
    var props = _ref2.props, isValueEmpty = _ref2.isValueEmpty, getLabel = _ref2.getLabel;
    return classNames("p-treeselect-label", {
      "p-placeholder": getLabel() === props.placeholder,
      "p-treeselect-label-empty": !props.placeholder && isValueEmpty
    });
  },
  panel: function panel(_ref3) {
    var props = _ref3.panelProps, context = _ref3.context;
    return classNames("p-treeselect-panel p-component", props.panelClassName, {
      "p-input-filled": context && context.inputStyle === "filled" || PrimeReact.inputStyle === "filled",
      "p-ripple-disabled": context && context.ripple === false || PrimeReact.ripple === false
    });
  },
  labelContainer: "p-treeselect-label-container",
  tokenLabel: "p-treeselect-token-label",
  token: "p-treeselect-token",
  trigger: "p-treeselect-trigger",
  triggerIcon: "p-treeselect-trigger-icon p-clickable",
  emptyMessage: "p-treeselect-empty-message",
  filterContainer: "p-treeselect-filter-container",
  filter: "p-treeselect-filter p-inputtext p-component",
  filterIcon: "p-treeselect-filter-icon",
  closeIcon: "p-treeselect-close-icon",
  clearIcon: "p-treeselect-clear-icon p-clickable",
  closeButton: "p-treeselect-close p-link",
  header: "p-treeselect-header",
  wrapper: "p-treeselect-items-wrapper",
  transition: "p-connected-overlay"
};
var styles2 = "\n@layer primereact {\n    .p-treeselect {\n        display: inline-flex;\n        cursor: pointer;\n        position: relative;\n        user-select: none;\n    }\n\n    .p-treeselect-trigger {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n    }\n\n    .p-treeselect-label-container {\n        overflow: hidden;\n        flex: 1 1 auto;\n        cursor: pointer;\n    }\n\n    .p-treeselect-label  {\n        display: block;\n        white-space: nowrap;\n        cursor: pointer;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n\n    .p-treeselect-label-empty {\n        overflow: hidden;\n        visibility: hidden;\n    }\n\n    .p-treeselect-token {\n        cursor: default;\n        display: inline-flex;\n        align-items: center;\n        flex: 0 0 auto;\n    }\n\n    .p-treeselect .p-treeselect-panel {\n        min-width: 100%;\n    }\n\n    .p-treeselect-items-wrapper {\n        overflow: auto;\n    }\n\n    .p-treeselect-header {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n    }\n\n    .p-treeselect-filter-container {\n        position: relative;\n        flex: 1 1 auto;\n    }\n\n    .p-treeselect-filter-icon {\n        position: absolute;\n        top: 50%;\n        margin-top: -.5rem;\n    }\n\n    .p-treeselect-filter-container .p-inputtext {\n        width: 100%;\n    }\n\n    .p-treeselect-close {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n        overflow: hidden;\n        position: relative;\n        margin-left: auto;\n    }\n\n    .p-treeselect-clear-icon {\n        position: absolute;\n        top: 50%;\n        margin-top: -.5rem;\n    }\n\n    .p-fluid .p-treeselect {\n        display: flex;\n}\n}\n";
var TreeSelectBase = ComponentBase.extend({
  defaultProps: {
    __TYPE: "TreeSelect",
    appendTo: null,
    ariaLabel: null,
    ariaLabelledBy: null,
    className: null,
    closeIcon: null,
    clearIcon: null,
    disabled: false,
    display: "comma",
    dropdownIcon: null,
    emptyMessage: null,
    expandedKeys: null,
    filter: false,
    filterBy: "label",
    filterIcon: null,
    filterInputAutoFocus: true,
    filterLocale: void 0,
    filterMode: "lenient",
    filterPlaceholder: null,
    filterTemplate: null,
    filterValue: null,
    inputId: null,
    inputRef: null,
    metaKeySelection: true,
    name: null,
    nodeTemplate: null,
    onChange: null,
    onFocus: null,
    onBlur: null,
    onFilterValueChange: null,
    onHide: null,
    onNodeCollapse: null,
    onNodeExpand: null,
    onNodeSelect: null,
    onNodeUnselect: null,
    onShow: null,
    options: null,
    panelClassName: null,
    panelFooterTemplate: null,
    panelHeaderTemplate: null,
    panelStyle: null,
    placeholder: null,
    resetFilterOnHide: false,
    scrollHeight: "400px",
    selectionMode: "single",
    showClear: false,
    style: null,
    tabIndex: null,
    togglerTemplate: null,
    transitionOptions: null,
    value: null,
    valueTemplate: null,
    children: void 0
  },
  css: {
    classes: classes2,
    styles: styles2
  }
});
function ownKeys$12(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$12(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$12(Object(t), true).forEach(function(r2) {
      _defineProperty2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$12(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var TreeSelectPanel = React3.forwardRef(function(props, ref) {
  var mergeProps = useMergeProps();
  var context = React3.useContext(PrimeReactContext);
  var ptm = props.ptm, cx = props.cx;
  var getPTOptions = function getPTOptions2(key, options) {
    return ptm(key, _objectSpread$12({
      hostName: props.hostName
    }, options));
  };
  var onKeyDown = function onKeyDown2(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      props.hide();
    }
  };
  var createElement4 = function createElement5() {
    var wrapperStyle = {
      maxHeight: props.scrollHeight || "auto"
    };
    var panelProps = mergeProps({
      className: cx("panel", {
        panelProps: props,
        context
      }),
      style: props.panelStyle,
      onKeyDown,
      onClick: props.onClick
    }, getPTOptions("panel"));
    var wrapperProps = mergeProps({
      className: cx("wrapper"),
      style: wrapperStyle
    }, getPTOptions("wrapper"));
    var transitionProps = mergeProps({
      classNames: cx("transition"),
      "in": props["in"],
      timeout: {
        enter: 120,
        exit: 100
      },
      options: props.transitionOptions,
      unmountOnExit: true,
      onEnter: props.onEnter,
      onEntered: props.onEntered,
      onExit: props.onExit,
      onExited: props.onExited
    }, getPTOptions("transition"));
    return React3.createElement(CSSTransition, _extends3({
      nodeRef: ref
    }, transitionProps), React3.createElement("div", _extends3({
      ref
    }, panelProps), props.firstHiddenFocusableElementOnOverlay, props.header, React3.createElement("div", wrapperProps, props.children), props.footer, props.lastHiddenFocusableElementOnOverlay));
  };
  var element = createElement4();
  return React3.createElement(Portal, {
    element,
    appendTo: props.appendTo
  });
});
TreeSelectPanel.displayName = "TreeSelectPanel";
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var TreeSelect = React3.memo(React3.forwardRef(function(inProps, ref) {
  var mergeProps = useMergeProps();
  var context = React3.useContext(PrimeReactContext);
  var props = TreeSelectBase.getProps(inProps, context);
  var _React$useState = React3.useState(false), _React$useState2 = _slicedToArray2(_React$useState, 2), focusedState = _React$useState2[0], setFocusedState = _React$useState2[1];
  var _React$useState3 = React3.useState(false), _React$useState4 = _slicedToArray2(_React$useState3, 2), overlayVisibleState = _React$useState4[0], setOverlayVisibleState = _React$useState4[1];
  var _React$useState5 = React3.useState(props.expandedKeys), _React$useState6 = _slicedToArray2(_React$useState5, 2), expandedKeysState = _React$useState6[0], setExpandedKeysState = _React$useState6[1];
  var _React$useState7 = React3.useState(""), _React$useState8 = _slicedToArray2(_React$useState7, 2), filterValueState = _React$useState8[0], setFilterValueState = _React$useState8[1];
  var elementRef = React3.useRef(null);
  var overlayRef = React3.useRef(null);
  var filterInputRef = React3.useRef(null);
  var focusInputRef = React3.useRef(props.inputRef);
  var triggerRef = React3.useRef(null);
  var selfChange = React3.useRef(null);
  var treeRef = React3.useRef(null);
  var firstHiddenFocusableElementOnOverlay = React3.useRef(null);
  var lastHiddenFocusableElementOnOverlay = React3.useRef(null);
  var focusToTree = React3.useRef(false);
  var listId = React3.useRef("");
  var expandedKeys = props.onToggle ? props.expandedKeys : expandedKeysState;
  var filteredValue = props.onFilterValueChange ? props.filterValue : filterValueState;
  var isValueEmpty = ObjectUtils.isEmpty(props.value);
  var hasNoOptions = ObjectUtils.isEmpty(props.options);
  var isSingleSelectionMode = props.selectionMode === "single";
  var isCheckboxSelectionMode = props.selectionMode === "checkbox";
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var metaData = {
    props,
    state: {
      focused: focusedState,
      overlayVisible: overlayVisibleState,
      expandedKeys,
      filterValue: filteredValue
    }
  };
  var _TreeSelectBase$setMe = TreeSelectBase.setMetaData(metaData), ptm = _TreeSelectBase$setMe.ptm, cx = _TreeSelectBase$setMe.cx, isUnstyled = _TreeSelectBase$setMe.isUnstyled;
  useHandleStyle(TreeSelectBase.css.styles, isUnstyled, {
    name: "treeselect"
  });
  var filterOptions = {
    filter: function filter(e) {
      return onFilterInputChange(e);
    },
    reset: function reset() {
      return resetFilter();
    }
  };
  var _useOverlayListener = useOverlayListener({
    target: elementRef,
    overlay: overlayRef,
    listener: function listener(event, _ref) {
      var valid = _ref.valid;
      valid && hide();
    },
    when: overlayVisibleState
  }), _useOverlayListener2 = _slicedToArray2(_useOverlayListener, 2), bindOverlayListener = _useOverlayListener2[0], unbindOverlayListener = _useOverlayListener2[1];
  var getLabel = function getLabel2() {
    return selectedNodes.length ? selectedNodes.map(function(node2) {
      return node2.label;
    }).join(", ") : props.placeholder;
  };
  var show = function show2() {
    setOverlayVisibleState(true);
  };
  var hide = function hide2() {
    setOverlayVisibleState(false);
    focusInputRef.current && DomHandler.focus(focusInputRef.current);
  };
  var onInputFocus = function onInputFocus2() {
    setFocusedState(true);
    props.onFocus && props.onFocus();
  };
  var onInputBlur = function onInputBlur2() {
    setFocusedState(false);
    props.onBlur && props.onBlur();
  };
  var onClick = function onClick2(event) {
    if (!props.disabled && (!overlayRef.current || !overlayRef.current.contains(event.target)) && !DomHandler.isAttributeEquals(event.target, "data-pc-section", "closebutton")) {
      DomHandler.focus(focusInputRef.current);
      overlayVisibleState ? hide() : show();
    }
  };
  var onSelectionChange = function onSelectionChange2(event) {
    if (props.onChange) {
      selfChange.current = true;
      props.onChange({
        originalEvent: event.originalEvent,
        value: event.value,
        stopPropagation: function stopPropagation() {
          event.originalEvent.stopPropagation();
        },
        preventDefault: function preventDefault() {
          event.originalEvent.preventDefault();
        },
        target: {
          name: props.name,
          id: props.id,
          value: event.value
        }
      });
    }
  };
  var clear = function clear2(event) {
    if (props.onChange) {
      selfChange.current = true;
      props.onChange({
        originalEvent: event,
        value: void 0,
        stopPropagation: function stopPropagation() {
          event.stopPropagation();
        },
        preventDefault: function preventDefault() {
          event.preventDefault();
        },
        target: {
          name: props.name,
          id: props.id,
          value: void 0
        }
      });
    }
  };
  var onNodeSelect = function onNodeSelect2(node2) {
    props.onNodeSelect && props.onNodeSelect(node2);
    isSingleSelectionMode && hide();
  };
  var onNodeUnselect = function onNodeUnselect2(node2) {
    props.onNodeUnselect && props.onNodeUnselect(node2);
    isCheckboxSelectionMode && node2.originalEvent.stopPropagation();
  };
  var onNodeToggle = function onNodeToggle2(e) {
    if (props.onToggle) {
      props.onToggle(e);
    } else {
      setExpandedKeysState(e.value);
    }
  };
  var onFilterValueChange = function onFilterValueChange2(e) {
    setFilterValueState(e.value);
  };
  var onOverlayClick = function onOverlayClick2(event) {
    OverlayService.emit("overlay-click", {
      originalEvent: event,
      target: elementRef.current
    });
  };
  var onFirstHiddenFocus = function onFirstHiddenFocus2(event) {
    var focusableEl = event.relatedTarget === focusInputRef.current ? DomHandler.getFirstFocusableElement(overlayRef.current, ':not([data-p-hidden-focusable="true"])') : focusInputRef.current;
    DomHandler.focus(focusableEl);
  };
  var onLastHiddenFocus = function onLastHiddenFocus2(event) {
    var focusableEl = event.relatedTarget === focusInputRef.current ? DomHandler.getLastFocusableElement(overlayRef.current, ':not([data-p-hidden-focusable="true"])') : focusInputRef.current;
    DomHandler.focus(focusableEl);
  };
  var onHeaderElementKeyDown = function onHeaderElementKeyDown2(event, isHideButton) {
    switch (event.code) {
      case "ArrowDown":
        event.preventDefault();
        setFocusToFocusableFirstNode();
        break;
      case "ArrowUp":
        event.preventDefault();
        focusInputRef.current && DomHandler.focus(focusInputRef.current);
        break;
      case "Space":
      case "Enter":
      case "NumpadEnter":
        event.preventDefault();
        if (isHideButton)
          hide();
        break;
      case "Escape":
        onEscapeKey(event);
        break;
    }
  };
  var onKeyDown = function onKeyDown2(event) {
    switch (event.code) {
      case "ArrowDown":
        onArrowDownKey(event);
        break;
      case "Space":
      case "Enter":
      case "NumpadEnter":
        onEnterKey(event);
        break;
      case "Escape":
        onEscapeKey(event);
        break;
      case "Tab":
        if (overlayVisibleState) {
          event.preventDefault();
          if (event.shiftKey)
            setFocusToFocusableFirstNode();
          else
            onTabKey(event);
        }
        break;
    }
  };
  var onArrowDownKey = function onArrowDownKey2(event) {
    if (overlayVisibleState)
      return;
    focusToTree.current = true;
    show();
    event.preventDefault();
  };
  var onEnterKey = function onEnterKey2(event) {
    if (overlayVisibleState) {
      hide();
    } else {
      onArrowDownKey(event);
    }
    event.preventDefault();
  };
  var onEscapeKey = function onEscapeKey2(event) {
    if (overlayVisibleState) {
      hide();
      event.preventDefault();
    }
  };
  var onTabKey = function onTabKey2(event) {
    var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!pressedInInputText) {
      if (overlayVisibleState && hasFocusableElements()) {
        DomHandler.focus(firstHiddenFocusableElementOnOverlay.current);
        event.preventDefault();
      }
    }
  };
  var hasFocusableElements = function hasFocusableElements2() {
    return DomHandler.getFocusableElements(overlayRef.current, ':not([data-p-hidden-focusable="true"])').length > 0;
  };
  var onFilterInputChange = function onFilterInputChange2(event) {
    var value = event.target.value;
    if (props.onFilterValueChange) {
      props.onFilterValueChange({
        originalEvent: event,
        value
      });
    } else {
      setFilterValueState(value);
    }
  };
  var resetFilter = function resetFilter2() {
    setFilterValueState("");
  };
  var onOverlayEnter = function onOverlayEnter2() {
    ZIndexUtils.set("overlay", overlayRef.current, context && context.autoZIndex || PrimeReact.autoZIndex, context && context.zIndex["overlay"] || PrimeReact.zIndex["overlay"]);
    DomHandler.addStyles(overlayRef.current, {
      position: "absolute",
      top: "0",
      left: "0"
    });
    setFocusToFocusableFirstNode();
    alignOverlay();
    scrollInView();
  };
  var onOverlayEntered = function onOverlayEntered2() {
    bindOverlayListener();
    if (props.filter && props.filterInputAutoFocus) {
      DomHandler.focus(filterInputRef.current, props.filterInputAutoFocus);
    }
    props.onShow && props.onShow();
  };
  var onOverlayExit = function onOverlayExit2() {
    unbindOverlayListener();
  };
  var onOverlayExited = function onOverlayExited2() {
    if (props.filter && props.resetFilterOnHide) {
      resetFilter();
    }
    ZIndexUtils.clear(overlayRef.current);
    props.onHide && props.onHide();
  };
  var alignOverlay = function alignOverlay2() {
    DomHandler.alignOverlay(overlayRef.current, triggerRef.current.parentElement, props.appendTo || context && context.appendTo || PrimeReact.appendTo);
  };
  var scrollInView = function scrollInView2() {
    var highlightItem = DomHandler.findSingle(overlayRef.current, '[data-pc-section="content"][data-p-highlight="true"]');
    if (highlightItem && highlightItem.scrollIntoView) {
      highlightItem.scrollIntoView({
        block: "nearest",
        inline: "start"
      });
    }
  };
  var findSelectedNodes = function findSelectedNodes2(node2, keys, selectedNodes2) {
    if (node2) {
      if (isSelected(node2, keys)) {
        selectedNodes2.push(node2);
        delete keys[node2.key];
      }
      if (Object.keys(keys).length && node2.children) {
        var _iterator = _createForOfIteratorHelper2(node2.children), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var childNode = _step.value;
            findSelectedNodes2(childNode, keys, selectedNodes2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    } else {
      var _iterator2 = _createForOfIteratorHelper2(props.options), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _childNode = _step2.value;
          findSelectedNodes2(_childNode, keys, selectedNodes2);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  };
  var isSelected = function isSelected2(node2, keys) {
    return isCheckboxSelectionMode ? keys[node2.key] && keys[node2.key].checked : keys[node2.key];
  };
  var updateTreeState = function updateTreeState2() {
    var keys = isSingleSelectionMode ? _defineProperty2({}, "".concat(props.value), true) : _objectSpread2({}, props.value);
    setExpandedKeysState({});
    if (keys && props.options) {
      updateTreeBranchState(null, null, keys);
    }
  };
  var setFocusToFocusableFirstNode = function setFocusToFocusableFirstNode2() {
    var treeNodeEl = DomHandler.find(treeRef.current.getElement(), '[data-pc-section="node"]');
    var focusedElement = _toConsumableArray2(treeNodeEl).find(function(item) {
      return item.getAttribute("tabindex") === "0";
    });
    DomHandler.focus(focusedElement);
  };
  var updateTreeBranchState = function updateTreeBranchState2(node2, path, keys) {
    if (node2) {
      if (isSelected(node2, keys)) {
        expandPath(path);
        delete keys[node2.key];
      }
      if (Object.keys(keys).length && node2.children) {
        var _iterator3 = _createForOfIteratorHelper2(node2.children), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var childNode = _step3.value;
            path.push(node2.key);
            updateTreeBranchState2(childNode, path, keys);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } else {
      var _iterator4 = _createForOfIteratorHelper2(props.options), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var _childNode2 = _step4.value;
          updateTreeBranchState2(_childNode2, [], keys);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  };
  var expandPath = function expandPath2(path) {
    if (path.length > 0) {
      var _expandedKeys = _objectSpread2({}, expandedKeysState || {});
      var _iterator5 = _createForOfIteratorHelper2(path), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var key = _step5.value;
          _expandedKeys[key] = true;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      setExpandedKeysState(_expandedKeys);
    }
  };
  var getSelectedNodes = function getSelectedNodes2() {
    var selectedNodes2 = [];
    if (ObjectUtils.isNotEmpty(props.value) && props.options) {
      var keys = isSingleSelectionMode ? _defineProperty2({}, "".concat(props.value), true) : _objectSpread2({}, props.value);
      findSelectedNodes(null, keys, selectedNodes2);
    }
    return selectedNodes2;
  };
  React3.useImperativeHandle(ref, function() {
    return {
      props,
      clear,
      show,
      hide,
      focus: function focus() {
        return DomHandler.focus(focusInputRef.current);
      },
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  React3.useEffect(function() {
    ObjectUtils.combinedRefs(focusInputRef, props.inputRef);
  }, [focusInputRef, props.inputRef]);
  useMountEffect(function() {
    updateTreeState();
    listId.current = UniqueComponentId() + "_list";
    if (props.autoFocus) {
      DomHandler.focus(focusInputRef.current, props.autoFocus);
    }
    alignOverlay();
  });
  useUpdateEffect(function() {
    if (overlayVisibleState && props.filter) {
      alignOverlay();
    }
  });
  useUpdateEffect(function() {
    updateTreeState();
  }, [props.options]);
  useUpdateEffect(function() {
    if (focusToTree.current && overlayVisibleState) {
      focusToTree.current = false;
      setFocusToFocusableFirstNode();
    }
  }, [overlayVisibleState]);
  useUpdateEffect(function() {
    if (overlayVisibleState && expandedKeysState) {
      alignOverlay();
    }
  }, [expandedKeysState]);
  useUpdateEffect(function() {
    if (overlayVisibleState) {
      if (!selfChange.current) {
        updateTreeState();
      }
      selfChange.current = false;
    }
  }, [props.value]);
  useUnmountEffect(function() {
    ZIndexUtils.clear(overlayRef.current);
  });
  var createKeyboardHelper = function createKeyboardHelper2() {
    var hiddenInputWrapperProps = mergeProps({
      className: "p-hidden-accessible"
    }, ptm("hiddenInputWrapper"));
    var hiddenInputProps = mergeProps(_objectSpread2({
      ref: focusInputRef,
      role: "listbox",
      id: props.inputId,
      type: "text",
      "aria-expanded": overlayVisibleState,
      "aria-label": props.ariaLabel,
      "aria-labelledby": props.ariaLabelledBy,
      "aria-haspopup": "tree",
      "aria-controls": listId.current,
      onFocus: onInputFocus,
      onBlur: onInputBlur,
      onKeyDown,
      disabled: props.disabled,
      tabIndex: props.tabIndex
    }, ariaProps), ptm("hiddenInput"));
    return React3.createElement("div", hiddenInputWrapperProps, React3.createElement("input", _extends3({}, hiddenInputProps, {
      readOnly: true
    })));
  };
  var createLabel = function createLabel2() {
    var tokenProps = mergeProps({
      className: cx("token")
    }, ptm("token"));
    var tokenLabelProps = mergeProps({
      className: cx("tokenLabel")
    }, ptm("tokenLabel"));
    var labelContainerProps = mergeProps({
      className: cx("labelContainer")
    }, ptm("labelContainer"));
    var labelProps = mergeProps({
      className: cx("label", {
        isValueEmpty,
        getLabel
      })
    }, ptm("label"));
    var content3 = null;
    if (props.valueTemplate) {
      content3 = ObjectUtils.getJSXElement(props.valueTemplate, selectedNodes, props);
    } else {
      if (props.display === "comma") {
        content3 = getLabel() || "empty";
      } else if (props.display === "chip") {
        content3 = React3.createElement(React3.Fragment, null, selectedNodes && selectedNodes.map(function(node2, index) {
          return React3.createElement("div", _extends3({}, tokenProps, {
            key: "".concat(node2.key, "_").concat(index)
          }), React3.createElement("span", tokenLabelProps, node2.label));
        }), isValueEmpty && (props.placeholder || "empty"));
      }
    }
    return React3.createElement("div", labelContainerProps, React3.createElement("div", labelProps, content3));
  };
  var createDropdownIcon = function createDropdownIcon2() {
    var triggerProps = mergeProps({
      ref: triggerRef,
      className: cx("trigger"),
      role: "button",
      "aria-haspopup": "tree",
      "aria-expanded": overlayVisibleState
    }, ptm("trigger"));
    var triggerIconProps = mergeProps({
      className: cx("triggerIcon")
    }, ptm("triggerIcon"));
    var icon = props.dropdownIcon || React3.createElement(ChevronDownIcon, triggerIconProps);
    var dropdownIcon2 = IconUtils.getJSXIcon(icon, _objectSpread2({}, triggerIconProps), {
      props
    });
    return React3.createElement("div", triggerProps, dropdownIcon2);
  };
  var createClearIcon = function createClearIcon2() {
    if (props.value != null && props.showClear && !props.disabled) {
      var clearIconProps = mergeProps({
        className: cx("clearIcon"),
        onPointerUp: clear
      }, ptm("clearIcon"));
      var icon = props.clearIcon || React3.createElement(TimesIcon, clearIconProps);
      return IconUtils.getJSXIcon(icon, _objectSpread2({}, clearIconProps), {
        props
      });
    }
    return null;
  };
  var createContent = function createContent2() {
    var emptyMessageProps = mergeProps({
      className: cx("emptyMessage")
    }, ptm("emptyMessage"));
    return React3.createElement(React3.Fragment, null, React3.createElement(Tree, {
      ref: treeRef,
      id: listId.current,
      expandedKeys,
      filter: props.filter,
      filterBy: props.filterBy,
      filterLocale: props.filterLocale,
      filterMode: props.filterMode,
      filterPlaceholder: props.filterPlaceholder,
      filterValue: filteredValue,
      metaKeySelection: props.metaKeySelection,
      nodeTemplate: props.nodeTemplate,
      onCollapse: props.onNodeCollapse,
      onExpand: props.onNodeExpand,
      onFilterValueChange,
      onSelect: onNodeSelect,
      onSelectionChange,
      onToggle: onNodeToggle,
      onUnselect: onNodeUnselect,
      selectionKeys: props.value,
      selectionMode: props.selectionMode,
      showHeader: false,
      togglerTemplate: props.togglerTemplate,
      value: props.options,
      pt: ptm("tree"),
      __parentMetadata: {
        parent: metaData
      }
    }), hasNoOptions && React3.createElement("div", emptyMessageProps, props.emptyMessage || localeOption("emptyMessage")));
  };
  var createFilterElement = function createFilterElement2() {
    if (props.filter) {
      var filterValue = ObjectUtils.isNotEmpty(filteredValue) ? filteredValue : "";
      var filterContainerProps = mergeProps({
        className: cx("filterContainer")
      }, ptm("filterContainer"));
      var filterProps = mergeProps({
        ref: filterInputRef,
        type: "text",
        value: filterValue,
        autoComplete: "off",
        className: cx("filter"),
        placeholder: props.filterPlaceholder,
        onKeyDown: function onKeyDown2(event) {
          return onHeaderElementKeyDown(event, false);
        },
        onChange: onFilterInputChange,
        disabled: props.disabled
      }, ptm("filter"));
      var filterIconProps = mergeProps({
        className: cx("filterIcon")
      }, ptm("filterIcon"));
      var icon = props.filterIcon || React3.createElement(SearchIcon, filterIconProps);
      var filterIcon = IconUtils.getJSXIcon(icon, _objectSpread2({}, filterIconProps), {
        props
      });
      var filterContent = React3.createElement("div", filterContainerProps, React3.createElement("input", filterProps), filterIcon);
      if (props.filterTemplate) {
        var defaultContentOptions = {
          className: "p-treeselect-filter-container",
          element: filterContent,
          filterOptions,
          filterInputKeyDown: function filterInputKeyDown(event) {
            return onHeaderElementKeyDown(event, function() {
            });
          },
          filterInputChange: onFilterInputChange,
          filterIconClassName: "p-dropdown-filter-icon",
          props
        };
        filterContent = ObjectUtils.getJSXElement(props.filterTemplate, defaultContentOptions);
      }
      return React3.createElement(React3.Fragment, null, filterContent);
    }
  };
  var createHeader = function createHeader2() {
    var filterElement = createFilterElement();
    var closeIconProps = mergeProps({
      className: cx("closeIcon"),
      "aria-hidden": true
    }, ptm("closeIcon"));
    var icon = props.closeIcon || React3.createElement(TimesIcon, closeIconProps);
    var closeIcon = IconUtils.getJSXIcon(icon, _objectSpread2({}, closeIconProps), {
      props
    });
    var closeButtonProps = mergeProps({
      type: "button",
      className: cx("closeButton"),
      onKeyDown: function onKeyDown2(event) {
        return onHeaderElementKeyDown(event, true);
      },
      onClick: hide,
      "aria-label": localeOption("close")
    }, ptm("closeButton"));
    var headerProps = mergeProps({
      className: cx("header")
    }, ptm("header"));
    var closeElement = React3.createElement("button", closeButtonProps, closeIcon, React3.createElement(Ripple, null));
    var content3 = React3.createElement("div", headerProps, filterElement, closeElement);
    if (props.panelHeaderTemplate) {
      var defaultOptions = {
        className: "p-treeselect-header",
        filterElement,
        closeElement,
        closeElementClassName: "p-treeselect-close p-link",
        closeIconClassName: "p-treeselect-close-icon",
        onCloseClick: hide,
        element: content3,
        props
      };
      return ObjectUtils.getJSXElement(props.panelHeaderTemplate, defaultOptions);
    }
    return content3;
  };
  var createFooter = function createFooter2() {
    return ObjectUtils.getJSXElement(props.panelFooterTemplate, props);
  };
  var selectedNodes = getSelectedNodes();
  var otherProps = TreeSelectBase.getOtherProps(props);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var firstHiddenFocusableElementOnOverlayProps = mergeProps({
    ref: firstHiddenFocusableElementOnOverlay,
    role: "presentation",
    className: "p-hidden-accessible p-hidden-focusable",
    tabIndex: 0,
    onFocus: onFirstHiddenFocus,
    "aria-hidden": true,
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }, ptm("firstHiddenFocusableElementOnOverlay"));
  var lastHiddenFocusableElementOnOverlayProps = mergeProps({
    ref: lastHiddenFocusableElementOnOverlay,
    role: "presentation",
    className: "p-hidden-accessible p-hidden-focusable",
    tabIndex: 0,
    onFocus: onLastHiddenFocus,
    "aria-hidden": true,
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }, ptm("lastHiddenFocusableElementOnOverlay"));
  var rootProps = mergeProps({
    ref: elementRef,
    className: cx("root", {
      focusedState,
      overlayVisibleState,
      isValueEmpty
    }),
    style: props.style,
    onClick
  }, TreeSelectBase.getOtherProps(props), ptm("root"));
  var keyboardHelper = createKeyboardHelper();
  var labelElement = createLabel();
  var dropdownIcon = createDropdownIcon();
  var clearIcon = createClearIcon();
  var content2 = createContent();
  var header = createHeader();
  var footer = createFooter();
  return React3.createElement("div", rootProps, keyboardHelper, labelElement, clearIcon, dropdownIcon, React3.createElement(TreeSelectPanel, {
    hostName: "TreeSelect",
    ref: overlayRef,
    appendTo: props.appendTo,
    panelStyle: props.panelStyle,
    panelClassName: props.panelClassName,
    scrollHeight: props.scrollHeight,
    onClick: onOverlayClick,
    header,
    hide,
    footer,
    firstHiddenFocusableElementOnOverlay: React3.createElement("span", firstHiddenFocusableElementOnOverlayProps),
    lastHiddenFocusableElementOnOverlay: React3.createElement("span", lastHiddenFocusableElementOnOverlayProps),
    transitionOptions: props.transitionOptions,
    "in": overlayVisibleState,
    onEnter: onOverlayEnter,
    onEntered: onOverlayEntered,
    onExit: onOverlayExit,
    onExited: onOverlayExited,
    ptm,
    cx
  }, content2), hasTooltip && React3.createElement(Tooltip, _extends3({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions, {
    pt: ptm("tooltip")
  })));
}));
TreeSelect.displayName = "TreeSelect";
export {
  TreeSelect
};
//# sourceMappingURL=primereact_treeselect.js.map
